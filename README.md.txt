Версия 1.0 от 04.01.2022

# Темы для экзамена в осеннем семестре ОРИС.

Здесь приводятся темы в общей формулировке. Хотя для некоторых из них раскрываются подтемы, это не значит, что раскрываются абсолютно все детали, которые нужно знать. Например, для темы "cookie" само собой нужно знать все свойства (атрибуты), для чего их использовать, как их использовать в Java, как реализуется их передача.
Некоторые темы можно объяснять на примерах с разными реализациями, о чём напрямую и говорится.
Большинство тем связаны с практическими умениями, поэтому нужно уметь написать код, который иллюстрирует работу технологии. Например, метод обработки запроса сервлетом, HTML-документ и т.д.
Будьте внимательны: некоторые темы одновременно относятся к нескольким разделам, но указаны в списке один раз. Не пропустите их. Также обратите внимание, что некоторые указанные тут темы не разбирались на лекциях и даже практиках. Это темы для самостоятельного изучения. С другой стороны не все темы из лекций есть в программе.
При ответе будут дополнительно оценены знания вне программы, но это не означает, что можно ответить по смежной с вопросом из билета теме.


1. HTTP-протокол (типы запросов, тело запроса, тело ответа, параметры запроса, заголовки, коды ответа, общая логкиа протокола), cookie, основные заголовки. Защита от повторной отправки форм.

2. Работа с HTTP в Java - веб-сервер, сервер приложений, контейнер сервлетов, сервлеты (логика работы, жизненный цикл сервлета, методы HttpServlet), фильтры, слушататели, структура war-архива приложения на сервлетах, конфигурация веб-приложения (web.xml и аннотации), сессии, контекст, внутреннее перенаправление. Общее_устройство/логика_работы/архитектура_сайта.

3. HTML, CSS - что, зачем, для чего, как пользоваться, основные HTML-элементы и их атрибуты (html, head, body, title, meta, h1-h6, p, a, img, div, span), понятие DOM, блочные-строчные элементы, подключение стилей к html-документу. Задание стилей, основные селекторы, задание цветов, размеров.

4. JS. Характеристики языка. Подключение JS к html-документу. Типы данных. Подписка на события. Получение элементов DOM. 

5. БД. Типы БД по разным признакам. Реляционные БД: таблицы, типы столбцов, связи, первичный ключ, внешний ключ, основные запросы SQL, объединения, индексы, нормальные формы. Понятие репликации и её типы. СУБД.

6. JDBC. java.sql (Connection, ResultSet, Statements, DriverManager), плюсы-минусы JDBC. Общая логика использования. SQL-инъекции. 

7. Шаблонизаторы (что такое, ответственности шаблонизаторов, что в них должно быть, что — нет). Использование JSP и JSTL-тегов (или Freemarker). 

8. GUI. Сравнение AWT, Swing, JavaFX. FXML и MVC для JavaFX. Далее на выбор Swing/JavaFX: что такое компонент, как создать окно, как добавить компоненты в окно, распределение компонент внутри родителя (layout) (Border + пара любых других примеров), как повесить обработчик события (или прикрепить контроллер в JavaFX), основные идеи работы с потоками.

9. Сетевые приложения. Сокеты и Datagram* в Java. Java NIO (каналы, буферы, селекторы) для сетевых приложений. Общение между программами через сеть, создание своего протокола. Модель OSI (примеры протоколов/семейств/технологий всех уровней). Основные идеи IP, TCP, UDP. Что такое интернет, веб. Порт, доменное имя, DNS, URI, URL encoding. 

10. Шаблоны проектирования и архитектуры. MVC (опционально MVP, MVVM). Бизнес-логика. Слои/уровни абстракции. Шаблона проектирования (суть, когда применять и примеры использования в конкретных ситуациях): Data Mapper, Active Record, Listener (+ EDD), Decorator, Singlton, Iterator, Adapter, Facade, Builder, Abstract Factory, Dependency Injection.

11. Прочее. Сборка проекта на примере Maven или Gradle на выбор (задачи/цели, структура проекта, описание проекта).  Работа с пользователем в сетевом/веб приложении (без сквозной авторизации). Текстовые форматы сериализации: синтаксис, характеристики (JSON, XML, ini, CSV. Опционально: YAML). MIME-типы. Абсолютные и относительные пути. XSS, HTML entities.




```
POST /app/prodcuts/add HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 228
User-Agent: Mozilla/5.0
Accept: text/html
Accept-Language: ru-RU
Refer: https://ya.ru/
Connection: keep-alive
Cookie: JSESSIONID=123456789

name=Шапочка%20для%20плавания&price=1999
```
```
HTTP/1.1 302 FOUND
Date: Wed, 27 JUL 2016 12:01:10 GMT
Server: Apache
Connection: Keep-Alive
Location https://example.com/news.php
```

### Реляционная алгебра - замкнутая система операций над отношениями в реляционной модели.

```
// Server.java
public class Server {
	private static final int port = 4444;
	
	public static void main(String[] args) {
		try(ServerSocket serverSocket = new ServerSocket(port)) {
			Socket firstClient = serverSocket.accept();
			Socket secondClient = serverSocket.accept();

			byte b = firstClient.getInputStream().read();

			secondClient.getOutputStream().write(b);
			secondClient.getOutputStream().flush();

			firstClient.close();
			secondClient.close();
			
		} catch (IOException e) { throw new IllegalArgumentException(e); }
		
	}
}

// FirstClient.java
public class FirstClient {
	private static final int port = 4444;
	private static final String host = "localhost";	

	public static void main(String[] args) {
		Socket client = new Socket(host, port);
		
		client.getOutputStream().write(0x1);
		client.getOutputStream().flush();
	}
}

// SecondClient.java
public class SecondClient {
	private static final int port = 4444;
	private static final String host = "localhost";

	public static void main(String[] args) {
		Socket client = new Socket(host, port);

		byte b = client.getInputStream().read();
		System.out.println(b);
	}
}
```

 ## Минусы модели OSI

 1. На разработку модели было потрачено огромное кол-во времени, разработчики не уделили внимания на существующие на то время стандарты. В связи с этим модель обвиняют в том, что она не отображает действительности. На момент выхода модели команиям было удобно работать с получившей широкое распространение TCP/IP.
 2. Протоколы OSI часто дублируют друг друга, функции распределены по уровням неравнозначно. Одни и те же задачи можно решить на разных уровнях 

## Модель OSI

 - Уровень 1: физический уровень

 Физический уровень определяет электрические и физические характеристики соединения данных. Например, расположение штырей разъема, рабочие напряжения электрического кабеля, спецификации оптоволоконного кабеля и частота для беспроводных устройств. Он отвечает за обмен физическими сигналами между физическими устройствами и аппаратурами. Управление скоростью передачи битов осуществляется на физическом уровне. Это уровень сетевого оборудования низкого уровня и никогда не касается протоколов или других элементов более высокого уровня.

 - Уровень 2: канальный уровень

 Канальный уровень предназначен для обеспечения взаимодействия сетей на физическом уровне и контроля ошибок, которые могут возникнуть. И второй уровень также решает проблему адресации при передаче информации. Полученные с физического уровня данные, представленные в битах, он упаковывает в кадры, проверяет их на целостность и, если нужно, исправляет ошибки (формирует повторный запрос повреждённого кадра) и отправляет на сетевой уровень.

 - Уровень 3: сетевой уровень

 Способ организации сети. Сеть - это среда, к которой можно подключить множество узлов. У каждого узла есть адрес. Когда узел должен передать сообщение другим узлам, он может просто предоставить содержание СМС и адреса узла назначения, затем сеть найдет способ доставки сообщения узлу назначения, возможно через другие узлы. Если сообщение слишком длинное, сеть может разделить его на несколько сегментов на одном узле, отправив их отдельно и повторно собрав фрагменты на другом узле.

 - Уровень 4: транспортный уровень

 Транспортный уровень обеспечивает функции и средства передачи последовательностей данных от источника к хосту назначения через одну или несколько сетей, сохраняя при этом функции quality of service (QoS) и обеспечивая полную доставку данных. Целостность данных может быть гарантирована через исправление ошибок и аналогичные функции. Он также может предоставить явную функцию управления потоком. Наиболее чувствительных к потерям на транспортном уровне используется протокол TCP, контролирующий целостность доставленной информации. Поэтому, протокол TCP используется для передачи четкой информации: картинки, тексты, файлы. Для передачи таких данных, наиболее чувствительных к задержкам, используется протокол UDP, позволяющий организовать связь без установки соединения. UDP же чаще всего используются в потоках: видео, аудио, онлайн-игры и т.д.

 - Уровень 5: сеансовый уровень

 Этот уровень модели OSI относится к «верхним». Здесь осуществляются операции с чистыми данными. Отвечает пятый уровень за поддержку связи во время сеанса или сессии. Он обеспечивает правильное взаимодействие между приложениями, позволяет синхронизировать разные задачи, обмениваться данными. Благодаря L5 происходит поддержка и завершение сеанса.

 Сеанс состоит из запросов и ответов, направляемых между разными приложениями. Сеансовый уровень используется в ПО, удаленно вызывающих процедуры. Примером работы L5 служит видеовызов в Skype или прямой эфир на широкую аудиторию. Во время сеанса нужно обеспечить синхронизованную передачу аудио и видео всем участникам конференции. За это и отвечают протоколы пятого уровня.  

 - Уровень 6: уровень представления

 Происходит представление данных либо в формате последовательности байтов (если идем с прикладного уровня вниз) или представление последовательности байтов в формат, который понимает прикладной уровень (если идем с нижних уровней).

 - Уровень 7: прикладной уровень

 Описание того, что непосредственно связано с программой.


## ServletContext

 Определяет набор методов, которые сервлет использует для коммуникации с сервлет-контейнером. Предоставляет доступ к параметрам веб-приложения. Например: получить MIME тип файла, отправлять запросы или писать в файл лога. ServletContext содержится внутри ServletConfig, который веб-сервер предоставляет сервлетам во время их инициализации.


### Написать метод сервлета, который обрабатывает заказ с именем товара, количеством и номером банковской карты

```
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) {
		String productName = req.getParameter("name");
		int count = req.getParameter("count");
		HttSession session = req.getSession(false);
		Integer cardNo = (Integer) session.getAttribute("cardNo");

		TransactionService transactionService = new TransactionService();

		if (transactionService.doTransaction(productName, count, cardNo)) {
			response.sendRedirect("/cart");
		} else {
			response.sendRedirect("/cart?errorId=13");
		}
	}
```











